package hu.bme.mit.gamma.codegenerator.cpp

import hu.bme.mit.gamma.statechart.model.Package
import hu.bme.mit.gamma.statechart.model.Port
import hu.bme.mit.gamma.statechart.model.composite.AsynchronousAdapter
import hu.bme.mit.gamma.statechart.model.composite.Component
import hu.bme.mit.gamma.statechart.model.interface_.Interface

class NameGenerator {

	final String PACKAGE_NAME

	new(String packageName) {
		this.PACKAGE_NAME = packageName
	}

	/**
	 * Returns the Java package name of the class generated from the component.
	 */
	def generateComponentPackageName (Component component) '''«PACKAGE_NAME».«component.containingPackage.name.toLowerCase»'''
 
 	/**
	 * Returns the name of the Java interface generated from the given Gamma interface. 
	 */
 	def generateName(Interface _interface) {
		return _interface.name.toFirstUpper + "Interface"
	}
 	
	/**
	 * Returns the name of the Java channel interface generated from the given Gamma interface. 
	 */
	def generateChannelName(Interface anInterface) {
		return anInterface.name.toFirstUpper + "Channel"
	}
	
	/**
	 * Returns the name of the Java channel interface generated from the given Gamma interface. 
	 */
	def generateChannelInterfaceName(Interface anInterface) {
		return anInterface.generateChannelName + "Interface"
	}
	
	/**
	 * Returns the name of the Java class of the component (the Yakindu statemachine wrapper).
	 */
	def generateComponentClassName(Component component) {
		return component.name.toFirstUpper
	}
		
	/**
	 * Returns the name of the Yakindu statemachine the given component is transformed from.
	 * They use it for package namings. It does not contain the "Statemachine" suffix."
	 */
	def getYakinduStatemachineName(Component component) {
		return component.containingPackage.name
	}
	
	/**
	 * Returns the name of the statemachine class generated by Yakindu.
	 */
	def getStatemachineClassName(Component component) {
		return component.yakinduStatemachineName + "Statemachine"
	}
	
	/**
	 * Returns the name of the wrapped Yakindu statemachine instance.
	 */
	def generateStatemachineInstanceName(Component component) {
		return component.statemachineClassName.toFirstLower
	}
	
	/**
	 * Returns the name of the wrapped synchronous component instance.
	 */
	def generateWrappedComponentName(AsynchronousAdapter wrapper) {
		return wrapper.wrappedComponent.name.toFirstLower
	}
	
	/**
	 * Returns the interface name (implemented by the component) of the given component.
	 */
	protected def generatePortOwnerInterfaceName(Component component) {
		return component.generateComponentClassName + "Interface";
	}
	
	/**
	 * Returns the name of the Java interface the given port realizes, e.g., Controller.Required.
	 */
	protected def getImplementedJavaInterfaceName(Port port) '''«port.interfaceRealization.interface.generateName».«port.interfaceRealization.realizationMode.toString.toLowerCase.toFirstUpper»'''
	
	/**
	 * Returns the name of the C++ interface the given port realizes, e.g., Controller.Required.
	 */
	protected def getImplementedCppInterfaceName(Port port) '''«port.interfaceRealization.interface.generateName»::«port.interfaceRealization.realizationMode.toString.toLowerCase.toFirstUpper»'''
	
	
	/**
	 * Returns the type name of the interface of the wrapped Yakindu statemachine.
	 */
	protected def getYakinduRealizationModeName(Port port) {
		 if (port.name === null) {
		 	return "SCInterface"
		 }
		 return "SCI" + port.name.toFirstUpper
	} 
	
	/**
	 * Returns the containing package of a component.
	 */
	protected def getContainingPackage(Component component) {
		return component.eContainer as Package
	}
	
}